This project is called Elevator Request Simulation, and it was created for Project 1C. The goal of this assignment was to create a program that uses data structures to simulate how elevators in buildings handle user requests. This is something we’ve all seen in real life, but now I got to build it in C++ and make it work using the tools we’ve learned like structs, classes, vectors, and queues. I worked on this project by myself, there were no other team members.
To start off, I had to make some choices about how my simulation would work. I chose to simulate a building that has 10 floors, labeled 0 through 9. That’s a realistic size for something like a school or small office. Then I had to decide how user requests would work. I chose to make them randomly generated, meaning the computer would pretend to be a bunch of people pressing elevator buttons at different times. For each person, the simulation creates a request that includes three things: the time the request was made, the floor they are on, and the floor they want to go to. That’s really all the elevator needs to know to do its job.
The way the elevator behaves is simple but also realistic. It moves one floor at a time, and it only stops if it needs to pick someone up or drop someone off. It doesn’t skip ahead or teleport — just like a real elevator. If there are multiple people inside the elevator, it drops them off one by one depending on what floor they’re going to. It doesn’t go in weird orders. It tries to keep going in one direction until it has to change. That makes it feel more realistic and keeps the wait times low.
For the code, I used two main parts: a Request struct and an Elevator class. The Request struct is used to hold all the information about each person who needs a ride. That includes the time they made the request, what floor they’re on, where they want to go, whether they’re going up or down, and an ID number to keep track of them. I added the goingUp part because sometimes it helps to know the direction, especially if you want to make smarter decisions about which requests to handle first.
The Elevator class is where most of the logic happens. It includes variables like the elevator’s ID number, the floor it’s currently on, the direction it’s moving (up, down, or not moving), and two important data structures: one queue to keep track of people who are waiting to get on the elevator, and a vector to keep track of people who are already inside. There’s also a variable called totalWaitingTime, which adds up all the time people had to wait from the moment they made their request to the moment they got dropped off. This is really important because it helps measure how well the elevator is working.
In terms of functions, the Elevator class includes addRequest, which adds a new person to the elevator’s queue. Then there’s step, which moves the elevator by one floor and checks if anyone inside needs to get off. If the elevator reaches someone’s destination floor, it lets them off and updates the total wait time. There’s also isIdle, which checks if the elevator is empty and has no requests. That’s useful when deciding which elevator should get the next request. Finally, getWaitingTimeSum returns the total wait time for that elevator so we can calculate how efficient everything was at the end.
The handleInside function is a private helper function. It checks if any users inside the elevator need to be dropped off at the current floor. If yes, it removes them from the list and logs the time they waited. It also helps decide whether the elevator should keep going up, go down, or stay still. The logic is designed to be simple, but it still works like a real elevator that serves requests in a logical order.
I also made a simulate function in the main program. This function runs the whole simulation. It starts a timer that goes from 0 to 100 (each number is like one second). Every time the loop runs, there’s a chance (like 20%) that a new user request will be created. If a request is made, it’s given to an elevator. If one elevator is idle, it gets the request right away. If not, the request just goes to whichever elevator is less busy. This works well in practice and keeps things moving.
When each elevator gets a request, it starts working on it. It goes to pick the person up and then takes them to the floor they want to go to. The elevators don’t just serve one person at a time. They can carry more than one person at once, so they are constantly dropping people off while moving to the next destination. This is a more realistic way to simulate how elevators actually work in big buildings.
In terms of performance, the program runs very efficiently. The addRequest function takes constant time, or O(1), because it just adds to the end of a queue. The step function takes O(n) time, where n is the number of users in the elevator, because it checks each one to see if they need to get off. The handleInside function is also O(k), where k is the number of people in the elevator. It loops through them and drops off anyone whose destination matches the current floor. Finally, the simulate function is O(t * e), where t is the number of time steps and e is the number of elevators. These are all efficient and reasonable time complexities for a program like this.
I did use some AI in this project but everything in this project is based on my own understanding of how elevators work and how data structures can simulate that behavior. I did use some information from the airline passenger simulation that we talked about in class but instead made an elevator simulation. That idea helped me understand how to generate users randomly and simulate wait times.
Working on this project helped me learn how to connect real-world systems to computer programs. It showed me how to take a system we use every day, like an elevator, and break it down into data and logic that a computer can understand. I also got more practice with C++ classes, functions, and memory-safe ways of looping through data. This project felt more real than a normal homework problem because it involved planning, logic, coding, and testing — just like what real developers do.
In conclusion, I’m happy with how my elevator simulation turned out. It works correctly and it helped me understand how to use data structures to solve real-world problems. The program compiles and runs, and the output is clean and easy to understand. It tracks how long users wait and tries to minimize that time by handling requests efficiently. 

